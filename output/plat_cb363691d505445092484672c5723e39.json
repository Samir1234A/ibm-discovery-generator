{
  "sdl_source_type": "platform",
  "field_launch_date": "2019-01-08T00:00:00",
  "changed": "2022-03-22T00:00:00",
  "field_platform_contacts": "Andrejs T Marelli| Neisa T Rathore| Olvido R Kacani| Yifei E Zamponi| Saaid Y Benamar| Talita O Laoukili",
  "field_communities_of_practice": "scalper's| tranquillizing| disclosing| fuzziest| flashgun| disliking| scalawag's| gauntness| Nanjing",
  "platform_leader_name": "Denia O Cuan",
  "field_banner_subhead": "earners flank",
  "platform_url": "https://jailor's.com",
  "sdl_date": "2020-08-24T00:00:00",
  "countryPublished": "Mauritania",
  "conference": "moralists dirks hv Om",
  "originalAuthorName": "Latia t Peino",
  "title": "hay Changsha's",
  "declaredTags": "cloud-hosted IT systems|Federal Communications Commission|GovCloud|Capacity Planning|NOAA",
  "releaseReason": "glazier/uproars",
  "docName": "DP_16_5195",
  "fundingCenter": 43,
  "resourceURL": "https://waked.com",
  "fundingDepartment": "ct39",
  "caseNumber": "14-2421",
  "publicationDate": "9/3/2020 12:00:00 AM",
  "releaseYear": 2012,
  "releaseStatement": "Public Collaboration/Benchmarking/Standards Body",
  "approver": "$Dominic $Flaks",
  "handCarry": 0,
  "authorDivision": "ic38",
  "copyrightOwner": "Larry Aguiar",
  "lastModifiedDate": "2/24/2001 12:00:00 AM",
  "releaseDate": "9/7/2012 12:00:00 AM",
  "onMitrePublicSrvr": 0,
  "projectNumber": "3346PIJN59",
  "materialType": "Book",
  "publicationType": "Paper",
  "authorCenter": 31,
  "originalAuthorID": "Anastasio",
  "mitrePublicServer": 0,
  "subjectTerminology": "Health Services Administration",
  "dateEntered": "7/24/2000 12:00:00 AM",
  "documentInfoURL": "https://hairnets Rutgers brandy's heartland Chrysostom's.com",
  "softShell": 0,
  "publishedOnNonMITREServer": 0,
  "priorCaseNumbers": "CASE1: 17-4547|CASE1: 17-4550",
  "organization": "uj33",
  "authorDepartment": "dd46",
  "publicationYear": 2008,
  "sensitivity": "Public",
  "copyrightText": "(c) 2016 The MITRE Corporation All Rights Reserved",
  "fundingSource": "CAMH FFRDC Contracts",
  "level1": "HR, Strat Comm & BD Ops/Dev",
  "fundingDivision": "sweets Slocum specialist's chicanery aeronautics's",
  "publishedOutsideUSA": 0,
  "level3": "vb55",
  "level2": "dn29",
  "sdl_id": "cb363691d505445092484672c5723e39",
  "text": "output value, it is computationally infeasible \\nto discover the original input HELLOWORLD in our example. Furthermore, changing 3 even one character (dropping the H) in the original input results in a completely different \\nhash value: sha256(ELLOWORLD) = \\n'0x7d26a27cec234907afe7ce f4b8eebb d3c5d1c100e' This makes it easy for hash functions to detect even the slightest change in an input string. \\nAlthough its easy to detect changes in our simple example by looking at the text, hash functions \\ncan help to guarantee the authenticity of more complex content where changes may not be as \\neasily noticeable. Hash functions are used to both ensure an individual block of transactions cannot be altered and \\nthat the order of blocks in the overall blockchain remains consistent. Once a block is created it \\ncannot be altered, and one cannot remove blocks or insert blocks into the middle of the \\nblockchain. This is further explained in Section 3.3. 3.1.2 Digital Signature \\nAnother cryptographic primitive used by blockchain technology is the digital signature. \\nCryptographic digital signatures are based on public key cryptography. They are the digital \\nequivalent of a traditional signature but are much more secure. Essentially a digital signature \\nprovides a way for anyone to mathematically verify that a party is willing to attest to some \\ndigital content. A digital signature requires a cryptographic key pair. The key pair consist of a private key, \\nsometimes referred to as the signing key, and a public key, also known as the verification key. \\nThe signing key is a securely generated random value, while the verification key is generated \\nfrom the signing key. The math behind the signature scheme ensures that it is computationally \\ninfeasible to reverse the processyou cannot learn the signing key from the verification key. The \\nsigning key should be securely controlled by the owner and never shared. On the other hand, the \\nverification key can be shared with anyone and is used along with the signed content to verify \\nthe validity and authenticity of the signature. For example, Bob is the owner of a key pair and uses his private key to sign the cryptographic \\nhash of some content to generate a signature on that content1. Given the corresponding public \\nkey, the content, and the generated signature, anyone can verify that Bob (uniquely) signed the \\ncontent. In the context of the blockchain, signature verification of a transaction is a critical step. If the \\nsignature is invalid, the transaction is rejected. Signatures are primarily used to ensure that all \\ndata and state on the blockchain cannot be illegitimately modified. Most blockchain implementations use Elliptic Curve Digital Signature Algorithm (ECDSA); \\nECDSA is a U.S. government standard. The algorithms behind ECDSA have undergone \\nconsiderable cryptographic analysis and are considered secure and more efficient than other \\nperhaps better known cryptographic algorithms such as RSA/Digital Signature Algorithm \\n(DSA). (Narayanan, Bonneau, Felten, Miller, & Goldfeder, 2016) \\n1 Quite often for efficiency a cryptographic hash of the content is signed, and not the content itself. If correctly implemented this \\ndoes not introduce any weaknesses in security. 4 3.2 Consensus \\nConsensus makes it possible for a decentralized network of machines to agree upon and share the \\nstate of the system. It is critical in ensuring participants can trust the transactions processed on \\nthe blockchaineven when they may not trust each other. For example, say Alice transfers 10 \\ndigital tokens to Bob. What prevents Alice from transferring the same 10 digital tokens to Carl? \\nIn the cryptocurrency world, this is known as the Double Spend Problem (Double Spend \\nProblem, 2017). Somehow the system must reconcile and share account information across a \\nnetwork of independent nodes to ensure Carl is not cheated out of his payment from Alice. Before Bitcoin, it was impossible to electronically transfer digital money without relying on a \\ncentralized authority to manage the state of the system. Bitcoin cleverly solved the double spend \\nproblem and eliminated the need for a middleman by simply distributing a copy of the ledger to \\nevery node on the network, so anyone can check the state of an account. However, this creates a new problem. How does a blockchain node know its being sent valid \\ninformation? What if messages are lost? What if a malicious actor is falsifying transactions or \\nblocks? This problem is best illustrated by the well-known Byzantine Generals Problem \\n(Byzantine Fault Tolerance, 2017). In the Byzantine Generals Problem, there is a group of generals surrounding a city. The generals \\nhave the ability to conquer the city if they coordinate the time of attack. However, if they do not \\nattack at the same time, they risk being defeated by the enemy. The generals can only coordinate \\nthrough messengers with no way to verify the authenticity of the message. Messengers may be \\ncaptured, preventing the delivery of a message. And traitors among the generals may deliberately \\nsend bad messages to disrupt coordination. How can this group successfully coordinate the attack \\nwithout relying on a centralized authority? Bitcoin solved the Byzantine Generals Problem \\nthrough a new form of consensus called Proof of Work (PoW). 3.2.1 Proof of Work (Nakamoto Consensus) \\nPublic blockchains such as Bitcoin or Ethereum, allow anyone to participate in the consensus \\nprocess as a miner. Miners compete (or effectively vote) to add new transactions to the \\nblockchain with computing power by expending a certain amount of Central Processing Unit \\n(CPU) cycles to solve a mathematical puzzle. This puzzle is intentionally computationally \\ndifficult to solve (Nakamoto, 2009), yet it is very easy to verify the answer. To add a block of new transactions to the blockchain, a miner must solve the puzzle. The first \\nminer to solve the puzzle sends (proposes) the block to the rest of the network for agreement. If \\nthe network agrees on the solution to the puzzle, the miner is rewarded for creating the block and \\nthe block is added to the blockchain (the miner wins this round of competition). Through a \\ncombination of game theory and economics (effectively betting CPU cycles, which cost money, \\nto win the reward), PoW incentivizes consensus instead of attempting to enforce it. Essentially a \\nminer is rewarded for securing the network. When nodes synchronize to the network, there is a chance malicious actors may try to send \\ninvalid blocks in an attempt to double spend. To prevent this, nodes follow a simple rule of \\nalways synchronizing to the longest chain of blocks. This is because the longest chain reflects the \\nmajority vote by the networkit is the one miners have done the most work on. Following the longest chain rule also reduces the number of protocol messages traditionally \\nrequired to synchronize a large number of distributed nodes, making it possible for a public 5 blockchain to scale to thousands of nodes. However, the downside of using the longest chain rule \\nis that blocks are never truly final. This is why public blockchains may advise waiting for 12 or \\nmore block confirmations to accept a transaction (Block Confirmation, 2016). An example of why this is necessary is that there are rare instances when the chain will split \\nunder normal operationwhen multiple miners solve a puzzle at virtually the same time. As \\nnoted, nodes choose to build on the longest chain. However, in this case, there are two valid \\nchoices. Based on PoW one chain will eventually win, becoming the longest chain (the \\nprobability of chains extending in parallel for more than one or two blocks is exceedingly small). \\nThe blocks in the shorter chain are often referred to as orphaned; and all transactions in these \\nblocks are effectively invalid until they are packaged into a new block. Thus, consensus is reached, but transaction settlement times are relatively long and transaction \\nrates are limited. 3.2.2 Byzantine Fault Tolerant (BFT) Consensus \\nWhile public blockchains rely on PoW, enterprise (or permissioned) blockchains tend to use \\nmore traditional BFT consensus protocols (Byzantine Fault Tolerance, 2017). BFT consensus is \\nbased on the idea that a pre-selected, authorized group of validators2 will create, verify, and attest \\nto new blocks. These validators take turns creating new blocks and submit a newly created block to other \\nvalidators for verification and vote. Each validator votes for a block by cryptographically signing \\nit. Once the network receives at least a 2/3 majority vote for a block, it is finalized and added to \\nthe blockchain. Since valid blocks will contain the digital signatures of the validators, nodes \\nsynchronizing to the blockchain need only check the validator signatures in a block to ensure \\nthey are following the correct blockchain. BFT consensus usually requires a certain minimum number nodes to ensure the network can \\noperate in the face of malicious actors, for example, 3F+13, where F is the number of faulty \\nnodes. Compared to PoW, this approach also requires the exchange of more protocol messages to \\ncoordinate the consensus process, limiting its scalability. While PoW can support thousands of \\nnodes, BFT is limited to at most hundreds. Table 1. Consensus Comparison. BFT Nakamoto Speed (transactions per second) Potentially 1000s < 20 on average Network Scalability 100s of nodes 1000s of nodes",
  "updated_at": "12/10/2019 12:00:00 AM",
  "created_at": "10/23/1992 12:00:00 AM"
}